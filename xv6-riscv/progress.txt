4/28
親プロセス、子プロセスの双方向をつなぐパイプを二つのパイプで表現できないかと考えた。
結果うまくいっていない。おそらくプロセス間のパイプ処理の同期ができていない。
親プロセスと子プロセスが交互に動くと思ったがログを見たところ親プロセスと子プロセスが一定時間連続で
動いている。
書き込み読み込みのfdを適切に閉じれば、自動的に同期がとれると思ったが間違いだったようだ。
ChatGptに聞いたところセマフォなどを使用する方法があるらしい。
本日は疲れたのでこれにて終了。

5/7
セマフォを使用方法を調べ、各プロセスの書き込み時にリソースをロックするようにしてみた。
だが結果はあまり変わらず。。。(result.txtを参照)
時間があまりとれなかったため今回はここで終わりとする。

セマフォ使用手順
1.インクルード
まず、セマフォを使用するためには、セマフォの操作を行うためのヘッダファイル <sys/sem.h> をインクルードします。
#include <sys/sem.h>
2.セマフォを操作するためのデータ構造 struct sembuf の定義。
struct sembuf {
    short sem_num;  // セマフォの番号
    short sem_op;   // セマフォの操作
    short sem_flg;  // フラグ
};　
3.次に、セマフォを作成するための関数 semget を使用。
int semget(key_t key, int nsems, int semflg);
key: セマフォを識別するためのキーです。
nsems: セマフォの数を指定します。
semflg: セマフォの作成やアクセス権限を指定します。
4.セマフォを操作するためには、semop 関数を使用
int semop(int semid, struct sembuf *sops, size_t nsops); 
semid: セマフォの識別子です。
sops: セマフォの操作を指定する struct sembuf の配列です。
nsops: sops 配列の要素数です。

・semctlについて
semctl は、セマフォセットに対して操作を行うための関数です。
主にセマフォの作成、設定、破棄などを行います。
以下に、semctl の基本的な使い方と一般的な操作を示します。

semctl 関数の基本的な使い方

---
#include <sys/sem.h>

int semctl(int semid, int semnum, int cmd, ...);
---


semid: セマフォセットを識別するための識別子（セマフォセットの ID）。
semnum: セマフォセット内のセマフォのインデックス（0 から始まる）。
cmd: 実行する操作を指定するコマンド。
cmd の種類
以下に一般的な cmd の値とその意味を示します。

GETVAL: 指定したセマフォの現在の値を取得する。
SETVAL: 指定したセマフォに新しい値を設定する。
IPC_RMID: セマフォセットを削除する。

